---
title: Questões da OBA
subtitle: Exercite seus conhecimentos em Astronomia com questões da Olimpíada Brasileira de Astronomia.
image: h5p_oba_logo.jpeg
format:
    html:
        include-in-header:
            text: |
                <style>
                    /* Estilos Globais */
                    body {
                    background: #f4f7f6;
                    color: #333;
                    }
                    /* Estilo do card do quiz */
                    .quiz-card {
                    background: #fff;
                    border: 1px solid #ddd;
                    border-radius: 8px;
                    margin-bottom: 20px;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    overflow: hidden;
                    }
                    .quiz-card-header {
                    background: #fafafa;
                    padding: 15px;
                    cursor: pointer;
                    //font-size: 1.2rem;
                    font-weight: 600;
                    border-bottom: 1px solid #ddd;
                    }
                    .quiz-card-header:hover {
                    background: #f0f0f0;
                    }
                    .quiz-card-body {
                    padding: 20px;
                    display: none;
                    }
                    .quiz-card-body.active {
                    display: block;
                    }
                    /* Estilos da interface do quiz */
                    .quiz-container {
                    max-width: 800px;
                    margin: auto;
                    }
                    .question-container {
                    background: #fafafa;
                    padding: 20px;
                    border-radius: 8px;
                    margin-bottom: 20px;
                    box-shadow: 0 2px 6px rgba(0,0,0,0.05);
                    transition: transform 0.5s ease, opacity 0.5s ease;
                    }
                    .alternativa {
                    margin-bottom: 15px;
                    }
                    .btn-action {
                    padding: 10px 20px;
                    border: none;
                    border-radius: 30px;
                    cursor: pointer;
                    transition: background 0.3s ease, transform 0.3s ease;
                    //font-size: 1rem;
                    }
                    .btn-action:hover {
                    transform: scale(1.05);
                    }
                    .btn-primary {
                    background-color: #5a67d8;
                    color: #fff;
                    }
                    .btn-info {
                    background-color: #48bb78;
                    color: #fff;
                    }
                    .btn-secondary {
                    background-color: #ccc;
                    color: #333;
                    }
                    .score-container {
                    text-align: center;
                    margin-top: 20px;
                    //font-size: 1.2rem;
                    }
                    .transition-question {
                    transition: transform 0.5s ease, opacity 0.5s ease;
                    }
                    .slide-left {
                    transform: translateX(-100%);
                    opacity: 0;
                    }
                    .slide-right {
                    transform: translateX(100%);
                    opacity: 0;
                    }
                    .current-question {
                    transform: translateX(0);
                    opacity: 1;
                    }
                    .hidden {
                    display: none !important;
                    }
                    .correct-bg { background-color: #e6ffed; }
                    .show-answer-bg { background-color: #fff9e6; } /* Not used anymore, keeping for reference if needed */
                    .incorrect-bg { background-color: #ffe6e6; }
                    .progress {
                    height: 10px;
                    background: #e2e8f0;
                    border-radius: 5px;
                    overflow: hidden;
                    margin-bottom: 10px;
                    }
                    .progress-bar {
                    height: 100%;
                    background: linear-gradient(90deg, #5a67d8, #48bb78);
                    width: 0%;
                    transition: width 0.3s ease;
                    }
                    /* Responsividade para os botões Verificar e Mostrar Resposta */
                    @media (max-width: 800px) {
                    .btn-group-responsive {
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        width: 100%;
                    }
                    .btn-group-responsive .btn-action {
                        width: 90%;
                        margin-bottom: 10px;
                    }
                    }
                    /* Feedback message style */
                    .feedback-message {
                        margin-top: 10px;
                        text-align: center;
                        font-weight: bold;
                    }
                    .feedback-correct { color: green; }
                    .feedback-partial { color: orange; }
                    .feedback-incorrect { color: red; }
                    .correct-text { color: green !important; } /* Class for correct answer text - important added */

                </style>
---

```{=html}
<!-- Container para os questionários -->
  <div id="quizzes"></div>

  <script>
    // Função para alternar a exibição do conteúdo (collapse)
    function toggleCollapse(event) {
      const header = event.currentTarget;
      const cardBody = header.nextElementSibling;
      cardBody.classList.toggle('active');
    }

    // Função que gera um novo questionário
    function gen_questionario(arquivoQuestoes, titulo) {
      // Gera um ID único para este quiz
      const quizId = "quiz" + Date.now() + Math.floor(Math.random() * 1000);
      const containerHTML = `
        <div class="quiz-card">
          <div class="quiz-card-header">${titulo}</div>
          <div class="quiz-card-body" id="${quizId}_body">
            <div class="quiz-container" id="${quizId}">
              <h3 style="text-align: center; margin-bottom: 20px;">${titulo}</h3>
              <div style="text-align: center; margin-bottom: 20px;">
                <label>
                  <input type="radio" name="${quizId}_quizMode" value="random" checked> Modo Aleatório
                </label>
                <label style="margin-left: 15px;">
                  <input type="radio" name="${quizId}_quizMode" value="sequential"> Modo Sequencial
                </label>
              </div>
              <div id="${quizId}_questionArea" class="question-container transition-question current-question">
                <!-- Questão será carregada aqui -->
              </div>
              <div style="text-align: center; margin-bottom: 10px;">
                <span id="${quizId}_questionNavigation">Questão 1 de 10</span>
              </div>
              <div style="margin-bottom: 20px;">
                <div class="progress">
                  <div id="${quizId}_questionProgress" class="progress-bar" role="progressbar"></div>
                </div>
                <div style="text-align: center;" id="${quizId}_progressText">0 questões amostradas</div>
              </div>
              <div class="score-container">
                Pontuação: <span id="${quizId}_currentScore">0</span> / <span id="${quizId}_maxScore">0</span>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 20px;">
                <button id="${quizId}_prevBtn" class="btn-action btn-secondary" disabled>Questão Anterior</button>
                <div class="btn-group-responsive">
                  <button id="${quizId}_verifyBtn" class="btn-action btn-primary" disabled>Verificar</button>
                  <button id="${quizId}_showAnswerBtn" class="btn-action btn-info" disabled>Mostrar Resposta</button>
                </div>
                <button id="${quizId}_nextBtn" class="btn-action btn-secondary">Próxima Questão</button>
              </div>
              <div id="${quizId}_finalResult" class="hidden" style="margin-top: 20px; padding: 10px; background: #e6ffe6; border: 1px solid #b2d8b2; border-radius: 5px; text-align: center;">
                Parabéns! Você completou o quiz. Sua pontuação final é: <span id="${quizId}_finalScoreValue"></span> / <span id="${quizId}_finalMaxScoreValue"></span>
                <button id="${quizId}_tryAgainBtn" class="btn-action btn-primary" style="margin-left: 10px; padding: 5px 10px;">Tentar Novamente</button>
              </div>
              <div id="${quizId}_feedbackArea" class="feedback-message"></div> <!-- Feedback message area -->
            </div>
          </div>
        </div>
      `;
      document.getElementById("quizzes").insertAdjacentHTML("beforeend", containerHTML);

      // Adiciona o evento de clique para o header (colapso)
      const cardHeaders = document.querySelectorAll('.quiz-card-header');
      cardHeaders.forEach(header => {
        header.addEventListener('click', toggleCollapse);
      });

      // Referência ao container específico do quiz
      const quizContainer = document.getElementById(quizId);

      // Variáveis e estado do quiz (escopo local para cada instância)
      let questions = [];
      let currentQuestionIndex = -1;
      let userAnswers = {};
      let score = 0;
      let maxPossibleScore = 0;
      let questionOrder = [];
      let quizMode = 'random';
      let answeredQuestions = {};
      let sampledQuestionCount = 0;
      let totalQuestions = 0;

      // Seleciona os elementos dentro deste quiz
      const questionArea = quizContainer.querySelector(`#${quizId}_questionArea`);
      const questionNavigationDisplay = quizContainer.querySelector(`#${quizId}_questionNavigation`);
      const progressTextDisplay = quizContainer.querySelector(`#${quizId}_progressText`);
      const questionProgress = quizContainer.querySelector(`#${quizId}_questionProgress`);
      const currentScoreDisplay = quizContainer.querySelector(`#${quizId}_currentScore`);
      const maxScoreDisplay = quizContainer.querySelector(`#${quizId}_maxScore`);
      const prevBtn = quizContainer.querySelector(`#${quizId}_prevBtn`);
      const nextBtn = quizContainer.querySelector(`#${quizId}_nextBtn`);
      const verifyBtn = quizContainer.querySelector(`#${quizId}_verifyBtn`);
      const showAnswerBtn = quizContainer.querySelector(`#${quizId}_showAnswerBtn`);
      const finalResultDiv = quizContainer.querySelector(`#${quizId}_finalResult`);
      const finalScoreValueDisplay = quizContainer.querySelector(`#${quizId}_finalScoreValue`);
      const finalMaxScoreValueDisplay = quizContainer.querySelector(`#${quizId}_finalMaxScoreValue`);
      const tryAgainBtn = quizContainer.querySelector(`#${quizId}_tryAgainBtn`);
      const quizModeRadios = quizContainer.querySelectorAll(`input[name="${quizId}_quizMode"]`);
      const feedbackArea = quizContainer.querySelector(`#${quizId}_feedbackArea`);


      // Função para carregar as questões do arquivo
      async function loadQuestions() {
        try {
          const response = await fetch(arquivoQuestoes);
          const text = await response.text();
          const questionBlocks = text.trim().split('---');
          questions = questionBlocks.map(block => {
            const lines = block.trim().split('\n').map(line => line.trim());
            let question = {};
            let alternativas = [];
            let readingAlternativas = false;
            for (const line of lines) {
              if (line.startsWith('tipo:')) {
                question.tipo = line.split(':')[1].trim();
              } else if (line.startsWith('enunciado:')) {
                question.enunciado = line.split(':')[1].trim();
              } else if (line.startsWith('caminhofig:')) {
                question.caminhofig = line.split(':')[1].trim();
              } else if (line.startsWith('pontuacao:')) { // Corrected label to "pontuacao"
                const scoreData = line.split(':')[1].trim();
                question.pontuacao = scoreData.split('],[').map(item => {
                  const parts = item.replace(/[\[\]]/g, '').split(',');
                  return { pattern: parts[0], score: parseFloat(parts[1]) };
                });
              }
              else if (line.startsWith('- ')) {
                readingAlternativas = true;
                let alternativaText = line.substring(2).trim();
                alternativas.push({ texto: alternativaText, correta: alternativaText.startsWith('X ') }); // Correctness now only from 'X ' prefix for parsing compatibility, but not used in scoring logic for multichoice
              } else if (readingAlternativas) {
                let alternativaText = line.trim();
                alternativas.push({ texto: alternativaText, correta: alternativaText.startsWith('X ') }); // Correctness now only from 'X ' prefix for parsing compatibility, but not used in scoring logic for multichoice
              }
            }
            question.alternativas = alternativas.map(alt => ({texto: alt.texto.replace(/^X\s+/, ''), correta: alt.correta})); // Remove 'X ' prefix after parsing, keep correta for singlechoice if needed
            return question;
          });
          totalQuestions = questions.length;
          initializeQuiz();
        } catch (error) {
          console.error('Erro ao carregar o arquivo de questões:', error);
        }
      }

      // Inicializa o quiz
      function initializeQuiz() {
        currentQuestionIndex = -1;
        userAnswers = {};
        score = 0;
        maxPossibleScore = totalQuestions;
        questionOrder = [...Array(questions.length).keys()];
        answeredQuestions = {};
        sampledQuestionCount = 0;
        finalResultDiv.classList.add('hidden');
        currentScoreDisplay.textContent = score;
        maxScoreDisplay.textContent = maxPossibleScore;
        quizMode = Array.from(quizModeRadios).find(r => r.checked).value;
        if (quizMode === 'random') {
          shuffleArray(questionOrder);
        }
        updateProgress();
        displayQuestion(0); // Load the first question without transition on init
      }

      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }

      function displayQuestion(index, transitionDirection = null) {
        if (index < 0 || index >= questions.length) return;
        currentQuestionIndex = index; // Update currentQuestionIndex here
        const question = questions[questionOrder[index]];
        const currentQuestionAnsweredState = answeredQuestions[questionOrder[index]] ? answeredQuestions[questionOrder[index]].state : null;
        const currentFeedbackText = answeredQuestions[questionOrder[index]] ? answeredQuestions[questionOrder[index]].feedbackText : '';
        const currentFeedbackClass = answeredQuestions[questionOrder[index]] ? answeredQuestions[questionOrder[index]].feedbackClass : '';


        questionArea.className = 'question-container transition-question current-question';
        feedbackArea.innerHTML = `<span class="${currentFeedbackClass}">${currentFeedbackText}</span>`;

        if (currentQuestionAnsweredState === 'correct') {
          questionArea.classList.add('correct-bg');
        } else if (currentQuestionAnsweredState === 'incorrect') {
          questionArea.classList.add('incorrect-bg');
        } else {
          questionArea.classList.remove('correct-bg', 'incorrect-bg'); // Remove background if not answered
        }
        const questionHTML = `
          <h5 style="margin-bottom: 15px;">${question.enunciado}</h5>
          ${question.caminhofig ? `<img src="${question.caminhofig}" style="max-width: 100%; border-radius: 8px; margin-bottom: 15px;" alt="Imagem da questão">` : ''}
        `;
        let shuffledAlternativesIndices = [...Array(question.alternativas.length).keys()];
        shuffleArray(shuffledAlternativesIndices);
        let alternativesHTML = '';
        for (let i = 0; i < shuffledAlternativesIndices.length; i++) {
          const originalIndex = shuffledAlternativesIndices[i];
          const alternativa = question.alternativas[originalIndex];
          alternativesHTML += `
            <div class="alternativa">
              <label id="altLabel${i}" > <!-- Added ID to label -->
                <input type="${question.tipo === 'multichoice' ? 'checkbox' : 'radio'}" name="${quizId}_answer" value="${originalIndex}" ${currentQuestionAnsweredState ? 'disabled' : ''}>
                ${alternativa.texto}
              </label>
            </div>
          `;
        }
        questionArea.innerHTML = questionHTML + alternativesHTML;
        questionNavigationDisplay.textContent = `Questão ${currentQuestionIndex + 1} de ${totalQuestions}`;
        if (userAnswers[questionOrder[index]]) {
          userAnswers[questionOrder[index]].forEach(answerIndex => {
            const inputElement = questionArea.querySelector(`input[name="${quizId}_answer"][value="${answerIndex}"]`);
            if (inputElement) {
              inputElement.checked = true;
            }
          });
        }

        verifyBtn.disabled = true; // Initially disabled on question display
        showAnswerBtn.disabled = true; // Initially disabled on question display

        if (answeredQuestions[questionOrder[index]]) {
          verifyBtn.disabled = true;
          showAnswerBtn.disabled = false; // Enable Show Answer if already verified
        }

        questionArea.querySelectorAll(`input[name="${quizId}_answer"]`).forEach(input => {
          input.addEventListener('change', function() {
            saveCurrentAnswers();
          });
        });

        prevBtn.disabled = index <= 0;
        nextBtn.disabled = index >= questions.length - 1;

        questionArea.classList.remove('current-question', 'slide-left', 'slide-right');
        if (transitionDirection === 'left') {
          questionArea.classList.add('slide-right');
          setTimeout(() => {
            questionArea.classList.remove('slide-right');
            questionArea.classList.add('current-question');
          }, 100);
        } else if (transitionDirection === 'right') {
          questionArea.classList.add('slide-left');
          setTimeout(() => {
            questionArea.classList.remove('slide-left');
            questionArea.classList.add('current-question');
          }, 100);
        } else {
          questionArea.classList.add('current-question');
        }
      }

      function saveCurrentAnswers() {
        const selectedIndices = getSelectedAnswers();
        userAnswers[questionOrder[currentQuestionIndex]] = selectedIndices;
        verifyBtn.disabled = selectedIndices.length === 0; // Enable Verify if at least one answer is selected, disable otherwise
      }

      function getSelectedAnswers() {
        const selectedIndices = [];
        questionArea.querySelectorAll(`input[name="${quizId}_answer"]:checked`).forEach(input => {
          selectedIndices.push(parseInt(input.value));
        });
        return selectedIndices;
      }

      function checkAnswer() {
        const currentQuestion = questions[questionOrder[currentQuestionIndex]];
        const selectedAnswerIndices = getSelectedAnswers();
        let questionScore = 0;
        let isCorrect = false; // Assume not fully correct initially
        let feedbackText = "Resposta errada: 0 pontos"; // Default feedback text
        let feedbackClass = 'feedback-incorrect'; // Default feedback class

        if (currentQuestion.tipo === 'multichoice' && currentQuestion.pontuacao) {
          const selectionPattern = currentQuestion.alternativas.map((_, index) => selectedAnswerIndices.includes(index) ? 'X' : '0').join('');
          let scored = false;
          for (const scoreRule of currentQuestion.pontuacao) {
            if (scoreRule.pattern === selectionPattern) {
              questionScore = scoreRule.score;
              scored = true;
              if (questionScore === 1) { // Assuming max score for full correct is 1
                  isCorrect = true;
                  feedbackText = "Parabéns: você obteve 1 de 1 ponto!";
                  feedbackClass = 'feedback-correct';
              } else if (questionScore > 0) {
                  feedbackText = `Quase: você obteve ${questionScore.toFixed(1)} de 1 ponto!`;
                  feedbackClass = 'feedback-partial';
              }
              break;
            }
          }
          if (!scored) {
              questionScore = 0;
          }
        } else { // singlechoice or multichoice without partial scores - full correct or incorrect
          isCorrect = verifyCorrectness(currentQuestion, selectedAnswerIndices);
          questionScore = isCorrect ? 1 : 0;
          feedbackText = isCorrect ? "Parabéns: você obteve 1 de 1 ponto!" : "Resposta errada: 0 pontos";
          feedbackClass = isCorrect ? 'feedback-correct' : 'feedback-incorrect';
        }


        score += questionScore;


        if (!answeredQuestions[questionOrder[currentQuestionIndex]]) {
          answeredQuestions[questionOrder[currentQuestionIndex]] = { state: isCorrect ? 'correct' : 'incorrect', answers: selectedAnswerIndices, questionScore: questionScore, feedbackText: feedbackText, feedbackClass: feedbackClass };
          sampledQuestionCount++;
          updateProgress();
        } else {
          answeredQuestions[questionOrder[currentQuestionIndex]].state = isCorrect ? 'correct' : 'incorrect';
          answeredQuestions[questionOrder[currentQuestionIndex]].questionScore = questionScore;
          answeredQuestions[questionOrder[currentQuestionIndex]].feedbackText = feedbackText;
          answeredQuestions[questionOrder[currentQuestionIndex]].feedbackClass = feedbackClass;
        }

        currentScoreDisplay.textContent = score.toFixed(1); // Display score with one decimal

        questionArea.classList.remove('correct-bg', 'incorrect-bg'); // Remove previous backgrounds
        if (isCorrect) {
          questionArea.classList.add('correct-bg');
        } else {
          questionArea.classList.add('incorrect-bg');
        }

        feedbackArea.innerHTML = `<span class="${feedbackClass}">${feedbackText}</span>`; // Display feedback message
        verifyBtn.disabled = true;
        showAnswerBtn.disabled = false; // Enable Show Answer after Verify
        //disableAnswerInputs();
        checkFinalResultCondition();
      }

      function verifyCorrectness(currentQuestion, selectedAnswerIndices) {
        let isCorrect = true;
        let correctCount = 0;
        let selectedCount = selectedAnswerIndices.length;
        currentQuestion.alternativas.forEach(alt => { if (alt.correta) correctCount++; });
        if (correctCount !== selectedCount) {
          isCorrect = false;
        } else {
          selectedAnswerIndices.forEach(selectedIndex => {
            if (!currentQuestion.alternativas[selectedIndex].correta) {
              isCorrect = false;
            }
          });
        }
        return isCorrect;
      }

      function showSolution() {
        const currentQuestion = questions[questionOrder[currentQuestionIndex]];        
        // Iterate through original alternatives (not shuffled)
        currentQuestion.alternativas.forEach((alternativa, originalIndex) => {
            const displayIndex = getAlternativeDisplayIndexFromOriginal(originalIndex); // Get display index
            console.log(displayIndex);
            if(displayIndex !== -1) { // Check if alternative is actually displayed
                const labelElement = questionArea.querySelector(`#altLabel${displayIndex}`); // Use display index to select label                
                if (alternativa.correta) {                    
                    labelElement.classList.add('correct-text'); // Add class to change text color to green
                } else {
                    labelElement.classList.remove('correct-text'); // Remove class for incorrect alternatives
                }
            }
        });


        verifyBtn.disabled = true;
        //showAnswerBtn.disabled = true;
        //disableAnswerInputs();
        checkFinalResultCondition();
      }


      // Helper function to get display index of alternative from original index (after shuffle)
      function getAlternativeDisplayIndexFromOriginal(originalIndex) {
            const shuffledIndices = questionArea.querySelectorAll('input[name="answer"]');
            for (let i = 0; i < shuffledIndices.length; i++) {
                if (parseInt(shuffledIndices[i].value) === originalIndex) {
                    return i;
                }
            }
            return -1; // Return -1 if not found (should not happen in normal flow)
        }


      function disableAnswerInputs() {
        questionArea.querySelectorAll(`input[name="${quizId}_answer"]`).forEach(input => {
          input.disabled = true;
        });
      }

      function nextQuestion() {
        if (currentQuestionIndex < questions.length - 1) {
          displayQuestion(currentQuestionIndex + 1, 'right');
        }
        prevBtn.disabled = false;
        nextBtn.disabled = currentQuestionIndex >= questions.length - 1;
        checkFinalResultCondition();
      }

      function previousQuestion() {
        if (currentQuestionIndex > 0) {
          displayQuestion(currentQuestionIndex - 1, 'left');
        }
        nextBtn.disabled = false;
        prevBtn.disabled = currentQuestionIndex <= 0;
      }

      function updateProgress() {
        const progressPercentage = (sampledQuestionCount / questions.length) * 100;
        questionProgress.style.width = `${progressPercentage}%`;
        progressTextDisplay.textContent = `${sampledQuestionCount} de ${questions.length} questões amostradas`;
      }

      function showFinalResult() {
        finalScoreValueDisplay.textContent = score.toFixed(1); // Final score with one decimal
        finalMaxScoreValueDisplay.textContent = maxPossibleScore;
        finalResultDiv.classList.remove('hidden');
      }

      function tryAgain() {
        initializeQuiz();
      }

      function checkFinalResultCondition() {
        if (sampledQuestionCount === questions.length) {
          showFinalResult();
        } else {
          finalResultDiv.classList.add('hidden');
        }
      }

      // Eventos
      verifyBtn.addEventListener('click', checkAnswer);
      showAnswerBtn.addEventListener('click', showSolution);
      nextBtn.addEventListener('click', nextQuestion);
      prevBtn.addEventListener('click', previousQuestion);
      tryAgainBtn.addEventListener('click', tryAgain);
      quizModeRadios.forEach(radio => {
        radio.addEventListener('change', () => { quizMode = radio.value; initializeQuiz(); });
      });

      // Carrega as questões do arquivo
      loadQuestions();
    }

    // Exemplos de chamadas – cada questionário funciona de forma independente
    //gen_questionario("/h5p/questionario1.txt", "Título 1");
    //gen_questionario("/h5p/questionario2.txt", "Título 2");
    gen_questionario("/h5p/questionario3.txt", "27ª OBA - Nível 1"); // Example call for the test question
  </script>